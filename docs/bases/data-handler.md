`backend.project.utils.handler.BaseDataHandler`

Класс для подготовки данных, например получение из БД:

```python
  {
      entity_id: 213,
      book_id: 12,
      user_ids: [1, 2, 3],
  } -> {
      entity: <Entity: 213>,
      book: <Book: 12>,
      users: <QuerySet [<User: 1>, <User: 2>, <User: 3>]>
  }
```

По умолчанию переводит названия `entity_id` -\> `entity`, `user_ids` -\> `users`, с помощью регулярных выражений. Такое поведение подходит в 95% случаев, а для всего остального есть атрибут `field_names`.

### Атрибуты:

* `field_names` - словарь преобразования имен. Необходим для указания названия объекта в подготовленном словаре.

### Методы:

* `prepare` - основной метод подготовки. Не принимает данные, преобразует те, что пришли в метод инициализации класса.
* `_prepare_<attr_name>` - метод подготовки атрибута `attr_name`. Должен вернуть подготовленное значение.

Для реализации своего класса подготовки необходимо унаследовать базовый класс и описать методы подготовки атрибутов:

```python
class BookDataHandler(BaseDataHandler):
    def _prepare_author_id(self):
        return Author.objects.get(pk=self.author_id)
        
    def _prepare_book_id(self):
        return Book.objects.get(pk=self.book_id, author=self.author)

raw_data: Dict[str, int] = { "book_id": 12, "author_id": 666 }

data_handler: BookDataHandler = BookDataHandler(handler=BaseHandler, user=user, data=raw_data)

prepared_data: Dict[str, Any] = data_handler.prepare()

print(prepared_data)
# { "book": <Book 12>, "author": <Author 666> }
```

Как происходит вычисление:

 1. Класс подготовки перебирает ключи из словаря сырых данных
 2. Получает ключ - `book_id`
 3. Ищет метод подготовки атрибута `_prepare_book_id`
 4. Вызывает метод подготовки
 5. Внутри метода подготовки используется 2 атрибута этого же класса (`book_id` и `author`).
 6. Как происходит вычисление значения атрибута:
    * Проверяет название атрибута в словаре уже подготовленных данных
    * Если в первом словаре нет - проверяет название в словаре начальных данных
 7. Первый атрибут (`book_id`) не найден в словаре подготовленных данных. Ищет в начальном словаре - находит
 8. Второй атрибут (`author`) не найден в словаре подготовленных данных. Ищет в начальном словаре - там тоже нет такого ключа
 9. В этот момент вызывается исключение - `NotReadyYet` (атрибут пока не готов к вычислению)
10. Атрибут `book_id` встает в конец очереди вычисления.
11. Получает ключ - `author_id`
12. Ищет метод подготовки атрибута `_prepare_author_id`
13. Вызывает метод подготовки
14. Внутри метода подготовки используется 1 атрибут этого же класса (`author_id`).
15. Первый атрибут (`author_id`) не найден в словаре подготовленных данных. Ищет в начальном словаре - находит
16. Теперь метод подготовки может получить автора из БД, после чего метод подготовки возвращает этот объект
17. Объект записывается в словарь подготовленных данных.
18. Дальше происходит вторая итерация обработки ключа `book_id`, но на этот раз все атрибуты, необходимые методу подготовки, уже готовы.
19. Ключи подготовки закончились, метод завершает выполнение и возвращает словарь подготовленных данных.


### Возможные ошибки:
1. Использование несуществующего атрибута. Здесь метод подготовки объекта `entity_id` хочет получить атрибут `another_entity`, которого нет судя по словарю начальных данных. В этом случае вы получите ошибку `DependencyCannotBeResolved` с названием атрибута, который невозможно вычислить.

```python
def _prepare_entity_id(self):
    return self.another_entity + 2

DataHandler(..., data={ "entity_id": 2 })

```

2. Циклическая зависимость атрибутов. Здесь методу подготовки автора нужна книга, а методу подготовки книги нужен автор. В этом случае вы получите ошибку `DependencyCannotBeResolved` с описанием циклической зависимости и названиями атрибутов, которые зависят друг от друга.


```python
def _prepare_author_id(self):
    return Author.objects.get(books=self.book)

def _prepare_book_id(self):
    return Book.objects.get(author=self.author)
```

<div align="center">
  
  [⇜ Базовые классы: SignalMixin](signal-mixin.md)
  •
  [Базовые классы: BaseHandler ⇝](handler.md)
</div>
